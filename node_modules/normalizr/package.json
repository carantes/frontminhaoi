{
  "_args": [
    [
      {
        "raw": "normalizr@https://registry.npmjs.org/normalizr/-/normalizr-1.4.1.tgz",
        "scope": null,
        "escapedName": "normalizr",
        "name": "normalizr",
        "rawSpec": "https://registry.npmjs.org/normalizr/-/normalizr-1.4.1.tgz",
        "spec": "https://registry.npmjs.org/normalizr/-/normalizr-1.4.1.tgz",
        "type": "remote"
      },
      "/home/nadiatrigo/code/migracao-minha-oi"
    ]
  ],
  "_from": "normalizr@>=1.0.0 <2.0.0",
  "_id": "normalizr@1.4.1",
  "_inCache": true,
  "_location": "/normalizr",
  "_phantomChildren": {},
  "_requested": {
    "raw": "normalizr@https://registry.npmjs.org/normalizr/-/normalizr-1.4.1.tgz",
    "scope": null,
    "escapedName": "normalizr",
    "name": "normalizr",
    "rawSpec": "https://registry.npmjs.org/normalizr/-/normalizr-1.4.1.tgz",
    "spec": "https://registry.npmjs.org/normalizr/-/normalizr-1.4.1.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/normalizr/-/normalizr-1.4.1.tgz",
  "_shasum": "aa387c2465f13611caf3aae42baf98f705e8a2ce",
  "_shrinkwrap": null,
  "_spec": "normalizr@https://registry.npmjs.org/normalizr/-/normalizr-1.4.1.tgz",
  "_where": "/home/nadiatrigo/code/migracao-minha-oi",
  "author": {
    "name": "Dan Abramov"
  },
  "bugs": {
    "url": "https://github.com/gaearon/normalizr/issues"
  },
  "dependencies": {
    "lodash": "^3.10.0"
  },
  "description": "Normalizes JSON according to schema for Flux application",
  "devDependencies": {
    "babel": "^5.8.3",
    "babel-core": "^5.8.3",
    "babel-loader": "^5.3.2",
    "chai": "^3.2.0",
    "mocha": "^2.2.5",
    "rimraf": "^2.4.2",
    "webpack": "^1.10.5"
  },
  "files": [
    "dist",
    "lib",
    "src"
  ],
  "homepage": "https://github.com/gaearon/normalizr",
  "keywords": [
    "flux",
    "normalize",
    "api",
    "json"
  ],
  "license": "MIT",
  "main": "lib/index.js",
  "name": "normalizr",
  "optionalDependencies": {},
  "readme": "# normalizr [![build status](https://img.shields.io/travis/gaearon/normalizr/master.svg?style=flat-square)](https://travis-ci.org/gaearon/normalizr) [![npm version](https://img.shields.io/npm/v/normalizr.svg?style=flat-square)](https://www.npmjs.com/package/normalizr) [![npm downloads](https://img.shields.io/npm/dm/normalizr.svg?style=flat-square)](https://www.npmjs.com/package/normalizr)\n\nNormalizes deeply nested JSON API responses according to a schema for [Flux](https://facebook.github.io/flux) and [Redux](http://rackt.github.io/redux) apps.  \nKudos to Jing Chen for suggesting this approach.\n\n## Installation\n\n```\nnpm install --save normalizr\n```\n\n## Sample App\n\n### Flux\n\nSee **[flux-react-router-example](https://github.com/gaearon/flux-react-router-example)**.\n\n### Redux\n\nSee **[redux/examples/real-world](https://github.com/rackt/redux/tree/master/examples/real-world)**.\n\n## The Problem\n\n* You have a JSON API that returns deeply nested objects;  \n* You want to port your app to [Flux](https://github.com/facebook/flux) or [Redux](http://rackt.github.io/redux);\n* You noticed [it's hard](https://groups.google.com/forum/#!topic/reactjs/jbh50-GJxpg) for Stores (or Reducers) to consume data from nested API responses.  \n\nNormalizr takes JSON and a schema and **replaces nested entities with their IDs, gathering all entities in dictionaries**.\n\nFor example,\n\n```javascript\n[{\n  id: 1,\n  title: 'Some Article',\n  author: {\n    id: 1,\n    name: 'Dan'\n  }\n}, {\n  id: 2,\n  title: 'Other Article',\n  author: {\n    id: 1,\n    name: 'Dan'\n  }\n}]\n```\n\ncan be normalized to\n\n```javascript\n{\n  result: [1, 2],\n  entities: {\n    articles: {\n      1: {\n        id: 1,\n        title: 'Some Article',\n        author: 1\n      },\n      2: {\n        id: 2,\n        title: 'Other Article',\n        author: 1\n      }\n    },\n    users: {\n      1: {\n        id: 1,\n        name: 'Dan'\n      }\n    }\n  }\n}\n```\n\nNote the flat structure (all nesting is gone).\n\n## Features\n\n* Entities can be nested inside other entities, objects and arrays;\n* Combine entity schemas to express any kind of API response;\n* Entities with same IDs are automatically merged (with a warning if they differ);\n* Allows using a custom ID attribute (e.g. slug).\n\n## Usage\n\n```javascript\nimport { normalize, Schema, arrayOf } from 'normalizr';\n```\n\nFirst, define a schema for our entities:\n\n```javascript\nconst article = new Schema('articles');\nconst user = new Schema('users');\nconst collection = new Schema('collections');\n```\n\nThen we define nesting rules:\n\n```javascript\narticle.define({\n  author: user,\n  collections: arrayOf(collection)\n});\n\ncollection.define({\n  curator: user\n});\n```\n\nNow we can use this schema in our API response handlers:\n\n```javascript\nconst ServerActionCreators = {\n\n  // These are two different XHR endpoints with different response schemas.\n  // We can use the schema objects defined earlier to express both of them:\n\n  receiveArticles(response) {\n  \n    // Passing { articles: arrayOf(article) } as second parameter to normalize()\n    // lets it correctly traverse the response tree and gather all entities:\n    \n    // BEFORE\n    // {\n    //   articles: [{\n    //     id: 1,\n    //     title: 'Some Article',\n    //     author: {\n    //       id: 7,\n    //       name: 'Dan'\n    //     }\n    //   }, ...]\n    // }\n    //\n    // AFTER:\n    // {\n    //   result: {\n    //    articles: [1, 2, ...] // <--- Note how object array turned into ID array\n    //   },\n    //   entities: {\n    //     articles: {\n    //       1: { author: 7, ... }, // <--- Same happens for references to other entities in the schema\n    //       2: { ... },\n    //       ...\n    //     },\n    //     users: {\n    //       7: { ... },\n    //       ..\n    //     }\n    //   }\n    \n    response = normalize(response, {\n      articles: arrayOf(article)\n    });\n\n    AppDispatcher.handleServerAction({\n      type: ActionTypes.RECEIVE_ARTICLES,\n      response\n    });\n  },\n  \n  // Though this is a different API endpoint, we can describe it just as well\n  // with our normalizr schema objects:\n\n  receiveUsers(response) {\n\n    // Passing { users: arrayOf(user) } as second parameter to normalize()\n    // lets it correctly traverse the response tree and gather all entities:\n    \n    // BEFORE\n    // {\n    //   users: [{\n    //     id: 7,\n    //     name: 'Dan',\n    //     ...\n    //   }, ...]\n    // }\n    //\n    // AFTER:\n    // {\n    //   result: {\n    //    users: [7, ...] // <--- Note how object array turned into ID array\n    //   },\n    //   entities: {\n    //     users: {\n    //       7: { ... },\n    //       ..\n    //     }\n    //   }\n    \n\n    response = normalize(response, {\n      users: arrayOf(user)\n    });\n\n    AppDispatcher.handleServerAction({\n      type: ActionTypes.RECEIVE_USERS,\n      response\n    });\n  }\n}\n```\n\nFinally, different Stores can tune in to listen to all API responses and grab entity lists from `action.response.entities`:\n\n```javascript\nAppDispatcher.register((payload) => {\n  const { action } = payload;\n\n  if (action.response && action.response.entities && action.response.entities.users) {\n    mergeUsers(action.response.entities.users);\n    UserStore.emitChange();\n    break;\n  }\n});\n```\n\n## API Reference\n\n### `new Schema(key, [options])`\n\nSchema lets you define a type of entity returned by your API.  \nThis should correspond to model in your server code.  \n\nThe `key` parameter lets you specify the name of the dictionary for this kind of entity.  \n\n```javascript\nconst article = new Schema('articles');\n\n// You can use a custom id attribute\nconst article = new Schema('articles', { idAttribute: 'slug' });\n\n// Or you can specify a function to infer it\nfunction generateSlug(entity) { /* ... */ }\nconst article = new Schema('articles', { idAttribute: generateSlug });\n```\n\n### `Schema.prototype.define(nestedSchema)`\n\nLets you specify relationships between different entities.  \n\n```javascript\nconst article = new Schema('articles');\nconst user = new Schema('users');\n\narticle.define({\n  author: user\n});\n```\n\n### `arrayOf(schema, [options])`\n\nDescribes an array of the schema passed as argument.\n\n```javascript\nconst article = new Schema('articles');\nconst user = new Schema('users');\n\narticle.define({\n  author: user,\n  contributors: arrayOf(user)\n});\n```\n\nIf the array contains entities with different schemas, you can use the `schemaAttribute` option to specify which schema to use for each entity:\n\n```javascript\nconst article = new Schema('articles');\nconst image = new Schema('images');\nconst video = new Schema('videos');\nconst asset = {\n  images: image,\n  videos: video\n};\n\n// You can specify the name of the attribute that determines the schema\narticle.define({\n  assets: arrayOf(asset, { schemaAttribute: 'type' })\n});\n\n// Or you can specify a function to infer it\nfunction inferSchema(entity) { /* ... */ }\narticle.define({\n  assets: arrayOf(asset, { schemaAttribute: inferSchema })\n});\n```\n\n### `valuesOf(schema, [options])`\n\nDescribes a map whose values follow the schema passed as argument.\n\n```javascript\nconst article = new Schema('articles');\nconst user = new Schema('users');\n\narticle.define({\n  collaboratorsByRole: valuesOf(user)\n});\n```\n\nIf the map contains entities with different schemas, you can use the `schemaAttribute` option to specify which schema to use for each entity:\n\n```javascript\nconst article = new Schema('articles');\nconst user = new Schema('images');\nconst group = new Schema('videos');\nconst collaborator = {\n  users: user,\n  groups: group\n};\n\n// You can specify the name of the attribute that determines the schema\narticle.define({\n  collaboratorsByRole: valuesOf(collaborator, { schemaAttribute: 'type' })\n});\n\n// Or you can specify a function to infer it\nfunction inferSchema(entity) { /* ... */ }\narticle.define({\n  collaboratorsByRole: valuesOf(collaborator, { schemaAttribute: inferSchema })\n});\n```\n\n### `normalize(obj, schema, [options])`\n\nNormalizes object according to schema.  \nPassed `schema` should be a nested object reflecting the structure of API response.\n\nYou may optionally specify any of the following options:\n\n* `assignEntity` (function): This is useful if your backend emits additional fields, such as separate ID fields, you'd like to delete in the normalized entity. See [the test](https://github.com/gaearon/normalizr/blob/47ed0ecd973da6fa7c8b2de461e35b293ae52047/test/index.js#L84-L130) and the [discussion](https://github.com/gaearon/normalizr/issues/10) for a usage example.\n\n* `mergeIntoEntity` (function): You can use this to resolve conflicts when merging entities with the same key. See [the test](https://github.com/gaearon/normalizr/blob/47ed0ecd973da6fa7c8b2de461e35b293ae52047/test/index.js#L132-L197) and the [discussion](https://github.com/gaearon/normalizr/issues/34) for a usage example.\n\n```javascript\nconst article = new Schema('articles');\nconst user = new Schema('users');\n\narticle.define({\n  author: user,\n  contributors: arrayOf(user),\n  meta: {\n    likes: arrayOf({\n      user: user\n    })\n  }\n});\n\n// ...\n\nconst json = getArticleArray();\nconst normalized = normalize(json, arrayOf(article));\n```\n\n## Explanation by Example\n\nSay, you have `/articles` API with the following schema:\n\n```\narticles: article*\n\narticle: {\n  author: user,\n  likers: user*\n  primary_collection: collection?\n  collections: collection*\n}\n\ncollection: {\n  curator: user\n}\n```\n\nWithout normalizr, your Stores would need to know too much about API response schema.  \nFor example, `UserStore` would include a lot of boilerplate to extract fresh user info when articles are fetched:\n\n```javascript\n// Without normalizr, you'd have to do this in every store:\n\nAppDispatcher.register((payload) => {\n  const { action } = payload;\n\n  switch (action.type) {\n  case ActionTypes.RECEIVE_USERS:\n    mergeUsers(action.rawUsers);\n    break;\n\n  case ActionTypes.RECEIVE_ARTICLES:\n    action.rawArticles.forEach(rawArticle => {\n      mergeUsers([rawArticle.user]);\n      mergeUsers(rawArticle.likers);\n\n      mergeUsers([rawArticle.primaryCollection.curator]);\n      rawArticle.collections.forEach(rawCollection => {\n        mergeUsers(rawCollection.curator);\n      });\n    });\n\n    UserStore.emitChange();\n    break;\n  }\n});\n```\n\nNormalizr solves the problem by converting API responses to a flat form where nested entities are replaced with IDs:\n\n```javascript\n{\n  result: [12, 10, 3, ...],\n  entities: {\n    articles: {\n      12: {\n        authorId: 3,\n        likers: [2, 1, 4],\n        primaryCollection: 12,\n        collections: [12, 11]\n      },\n      ...\n    },\n    users: {\n      3: {\n        name: 'Dan'\n      },\n      2: ...,\n      4: ....\n    },\n    collections: {\n      12: {\n        curator: 2,\n        name: 'Stuff'\n      },\n      ...\n    }\n  }\n}\n```\n\nThen `UserStore` code can be rewritten as:\n\n```javascript\n// With normalizr, users are always in action.entities.users\n\nAppDispatcher.register((payload) => {\n  const { action } = payload;\n\n  if (action.response && action.response.entities && action.response.entities.users) {\n    mergeUsers(action.response.entities.users);\n    UserStore.emitChange();\n    break;\n  }\n});\n```\n\n## Dependencies\n\n* `lodash` for `isObject`, `isEqual` and `mapValues`\n\n## Running Tests\n\n```\ngit clone https://github.com/gaearon/normalizr.git\ncd normalizr\nnpm install\nnpm test # run tests once\nnpm run test:watch # run test watcher\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/gaearon/normalizr.git"
  },
  "scripts": {
    "build": "webpack && babel src --out-dir lib",
    "prebuild": "rimraf dist lib",
    "prepublish": "npm run build",
    "test": "mocha --compilers js:babel/register --recursive",
    "test:watch": "npm run test -- --watch"
  },
  "version": "1.4.1"
}
